

class CalcMatrixTime:
	def __init__(self, data, states_list_not_final, states_list_final,  names_sem: list, time_between_sem_sec = 20):
		# note that the number of directions is autogenerated
		self.num_dir = 3
		self.number_states = len(states_list_not_final)
		self.states_list = states_list_not_final
		self.states_list_len = len(states_list_not_final)
		self.states_list_final = states_list_final
		self.states_list_final_len = len(states_list_final)
		self.data = data
		self.names_sem = names_sem
		self.time_sem = time_between_sem_sec
		self.rows_hour = int(((60*60)/self.time_sem + 1))

	def create_matrix(self, action: str):
		my_action = [action]
		my_matrix = []
		# we go through each state ( iteration of rows in matrix )
		row = 0
		# while row < self.number_states:
		column1 = 0
		first_row = ["Initial state"]
		while column1 < self.states_list_len:
			first_row.append(self.states_list_final[column1])
			column1 += 1
		my_matrix.append(first_row)
		while row < self.states_list_len:
			new_row = [self.states_list[row]]
			column = 0

			my_counter = 0
			my_counter_all = 0
			# we go through each state ( iteration in columns for each row )
			while column < self.states_list_final_len:
				hour = 0
				timer = 0
				while hour < 24:

					i = 1
					prob_hour = []
					my_counter = 0
					my_counter_all = 0
					while i < self.rows_hour:
						#print(self.data[i + timer][1])
						if self.data[i + timer][0] == self.states_list[row] and self.data[i + timer][1] == my_action:
							my_counter_all += 1
							if self.data[i][2] == self.states_list_final[column]:
								my_counter += 1
						i += 1
					timer += self.rows_hour
					print(timer)
					prob_hour.append(my_counter / my_counter_all)
					hour += 1
				column += 1
				new_row.append(prob_hour)
			my_matrix.append(new_row)
			row += 1

		return my_matrix























