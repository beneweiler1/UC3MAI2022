

class CalcProb:
	def __init__(self, data, states_list, names_sem: list):
		# note that the number of directions is autogenerated
		self.num_dir = len(states_list[0])
		self.init_state = states_list
		self.data = data
		self.names_sem = names_sem

	def calc(self):
		"""This method will provide a list with the probabilities of each direction to turn """
		red_result = []
		green_result = []
		count_prob_green = 0
		count_total_green = 0
		count_prob_red = 0
		count_total_red = 0
		e = 0

		while e < self.num_dir:
			i = 1
			while i < len(self.data):
				# if the initial state of the asked state is high
				# ##############################################################################################(1)

				if self.init_state[e] == "High":
					# if the initial cond of the row at this direction is high

					if self.data[i][e] == "High":
						# if in the dir we try to green
						# #######################################################################(2)
						if self.data[i][self.num_dir] == self.names_sem[e]:
							# if final state is low
							# #########################################################(3)
							if self.data[i][e + self.num_dir + 1] == "Low":
								count_prob_green += 1
							# we are counting the total of rows with initial
							# state high and green light equal to the direction wanted
							# #########################################################(3)
							count_total_green += 1
						# #######This case is imposible, traffic cant go down on redlight
						else:

							if self.data[i][e + self.num_dir + 1] == "Low":
								count_prob_red += 1
							count_total_red += 1
						# #######################################################################(2)
					# covering the case of traffic being low in the initial state
				else:
					if self.data[i][e] == "Low":
						# if our direction is turned green
						# #######################################################################(2)
						if self.data[i][self.num_dir] == self.names_sem[e]:
							# if final state is low
							# #########################################################(3)
							if self.data[i][e + self.num_dir + 1] == "Low":
								count_prob_green += 1
							# #########################################################(3)
								# we are counting the total of rows with initial
								# state high and green light equal to the direction wanted
							count_total_green += 1
							# we add one no matter the final result, this would be the total cases considered
						else:
							# ##########################################################(3)
							if self.data[i][e + self.num_dir + 1] == "Low":
								count_prob_red += 1
							count_total_red += 1
							# ##########################################################(3)
						# ########################################################################(2)
				# ##############################################################################################(1)
				i += 1
			e += 1
			green_result.append((count_prob_green / count_total_green))
			red_result.append((count_prob_red / count_total_red))
			count_prob_green = 0
			count_total_green = 0
			count_prob_red = 0
			count_total_red = 0

		return red_result, green_result






















